#lang racket

; 练习 1.1

10 ; -> 10

(+ 5 3 4) ; -> 12

(- 9 1) ; -> 8

(/ 6 2) ; 3

(+ (* 2 4) (- 4 6)) ; 6

(define a 3) ; 声明了 a -> 3

(define b (+ a 1)) ; 声明了 b 为 4

(+ a b (* a b)) ; -> 19

(= a b) ; #f

(if (and (> b a) (< b (* a b)))
    b
    a)  ; -> 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ; -> 16

(+ 2 (if (> b a) b a)) ; -> 6

(* (cond ([> a b] a)
         ([< a b] b)
         (else -1))
   (+ a 1)) ; -> 16


; 练习 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))

; 练习 1.3

; 第一种实现;
(define (max-sum1 a b c)
   (cond ((and [> a c] [> b c] (+ a b)))
         ((and [> a b] [> c b] (+ a c)))
         (else (+ b c))))

(display "1.3 第一种实现: \n")
(= (max-sum1 1 2 3) 5)
(= (max-sum1 1 3 2) 5)
(= (max-sum1 3 2 1) 5)
(= (max-sum1 3 4 4) 8)

; 第二种实现
(define (bigger x y)
  (if (> x y) x y))

(define (smaller x y)
  (if (< x y) x y))

(define (max-sum2 x y z)
  (+ (bigger (smaller x y) z)
     (bigger x y)))

(display "1.3 第二种实现: \n")
(= (max-sum2 1 2 3) 5)
(= (max-sum2 1 3 2) 5)
(= (max-sum2 3 2 1) 5)
(= (max-sum2 3 4 4) 8)

; 练习 1.4
; 定义 a-plus-abs-b 过程，参数为 a、b，如果 b 大于 0 结果就是 a + b 的值，否则就是 a - b 的值.

; 练习 1.5
; 我们之前学了两种求值方法。分别是「正则序求值」和「应用序求值」。下面的代码会在这不同的求值方法中有不同的体现：

(define (p) (p))

(define (test x y)
  (if (= x 0)
         0
         y))

(test 0 (p))

; 应用序:
; 如果是在「应用序」法则里面，我们会看到报错。这是因为应用序是采用「先求值参数而后应用」的求值模型。
; 在计算 (test 0 (p)) 表达式的时候，应用序会调用 (p) 过程, 由于这个过程会一直调用自身，陷入无限循环。所以导致出错。

; 正则序:
; 而正则序则不同，正则序采用「完全展开而后归约」的求值模型。
; 我们可以把它理解为惰性的。只有用到它的时候，它才开始计算。而我们在计算 (test 0 (p)) 表达式的时候，由于在过程体中，走到 (= x 0) 表达式的时候，就会计算出 0 的结果，所以根本不会计算到 (p)，当然也就不会出现问题了。

