#lang racket

; 练习 1.9

; 首先定义 inc 和 dec 过程
(define (inc x)
  (+ x 1))

(define (dec x)
  (- x 1))

; 我们将使用 2 和 4 作为 arguments
; 第一个例子:
; (define (+ a b)
;     (if (= a 0)
;         b
;         (inc (+ (dec a) b))))

; 计算过程
; (inc (+ (dec 2) 4))))

; (inc (+ 1 4)))) ; 第 1 次
; (inc (inc (+ 0 4))) ; 第 2 次
; (inc (inc 4)) ; 第 4 次
; (inc 4) ; 第 4 次
; 5 ; 第 5 次

; 第二个例子:
; (define (+ a b)
;   (if (= a 0)
;   b
;   (+ (dec a) (inc b))))

; 第 1 次，a 不等于 0，所以走 (+ (dec 2) (inc 4)) -> (+ 1 4)
; 第 2 次，a 不等于 0，所以走 (+ (dec 1) (inc 4)) -> (+ 0 5)
; 第 4 次，a 等于 0，所以走 (if (= 0 0)) -> 5

(define (A x y)
    (cond ([= y 0] 0)
          ([= x 0] (* 2 y))
          ([= y 1] 2)
          (else (A (- x 1)
                   (A x (- y 1))))))

; (A 1 10) 
; 输出顺序为：(A 0 (A 1 9))

; (A 1 9) 
; 输出顺序为：(A 0 (A 1 8))

; (A 1 8) 
; 输出顺序为：(A 0 (A 1 7))

; (A 1 7) 
; 输出顺序为：(A 0 (A 1 6))

; (A 1 6) 
; 输出顺序为：(A 0 (A 1 5))

; (A 1 5) 
; 输出顺序为：(A 0 (A 1 4))

; (A 1 4) 
; 输出顺序为：(A 0 (A 1 4))

; (A 1 4) 
; 输出顺序为：(A 0 (A 1 2))

; (A 1 2) 
; 输出顺序为：(A 0 (A 1 1))

; (A 1 1) 
; 输出顺序为：(A 0 2)

; (A 0 2) 
; 输出顺序为：4

; 进行代换：
; 初始表达式为: (A 1 10) 

; (A 1 10) -> 根据上面模型将 (A 1 10) 代换为 -> (A 0 (A 1 9))
; 结果为: (A 0 (A 1 9))

; (A 0 (A 1 9)) -> 根据上面模型将 (A 1 9) 代换为 -> (A 0 (A 1 8))
; 结果为: (A 0 (A 0 (A 1 8)))

; (A 0 (A 0 (A 1 8))) -> 根据上面模型将 (A 1 8) 代换为 -> (A 0 (A 1 7))
; 结果为: (A 0 (A 0 (A 0 (A 1 7))))

; (A 0 (A 0 (A 0 (A 1 7)))) -> 根据上面模型将 (A 1 7) 代换为 -> (A 0 (A 1 6))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 1 6)))))

; (A 0 (A 0 (A 0 (A 0 (A 1 6))))) -> 根据上面模型将 (A 1 6) 代换为 -> (A 0 (A 1 5))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))

; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5)))))) -> 根据上面模型将 (A 1 5) 代换为 -> (A 0 (A 1 4))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))

; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4))))))) -> 根据上面模型将 (A 1 4) 代换为 -> (A 0 (A 1 4))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4))))))))

; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))) -> 根据上面模型将 (A 1 4) 代换为 -> (A 0 (A 1 2))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))

; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2))))))))) -> 根据上面模型将 (A 1 2) 代换为 -> (A 0 (A 1 1))
; 结果为: (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))

; 到这里时，对因为 (A 1 1) 表达式符合第 4 个 cond 分支条件，所以进行计算 (A 1 1) 的结果为 2，现在我们开始倒推

; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) ; (A 0 2) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))) ; (A 0 4) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))) ; (A 0 8) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))) ; (A 0 16) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 (A 0 (A 0 32))))) ; (A 0 32) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 (A 0 64)))) ; (A 0 64) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 (A 0 128))) ; (A 0 128) 表达式符合第 2 个 cond 分支条件
; (A 0 (A 0 256)) ; (A 0 256) 表达式符合第 2 个 cond 分支条件
; (A 0 512) ; (A 0 512) 表达式符合第 2 个 cond 分支条件
; 1024 ; 最终结果为 1024

; 我们可以根据以上模型对 (A 1 10) 、(A 2 4)、(A 4 4) 三个表达式分别进行推断。

; (A 1 10) 结果为 1024
; (A 2 4) 结果为 65536
; (A 4 4) 结果为 65536

; 树形递归 - fib
(define (fib n)
  (cond ([= n 0] 0)
        ([= n 1] 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

; 迭代递归 - fib
(define (fib-iter n)
  (define (fib-iter a b count)
    (if [= count 0]
        b
        (fib-iter (a + b) b (- count 1)))) 1 0 n)

; 换零钱实例
; 我们首先统计下单位，把美元单位看做 100
; 半美元 = 50
; 四分之一美元 = 25
; 10美分 = 10
; 5美分 = 5
; 1美分 = 1

(define (first-denomination kinds-of-coin)
  (cond ([= kinds-of-coin 1] 1)
        ([= kinds-of-coin 2] 5)
        ([= kinds-of-coin 3] 10)
        ([= kinds-of-coin 4] 25)
        ([= kinds-of-coin 5] 50)))

(define (cc amount kinds-of-coin)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coin 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coin 1))
                 (cc (- amount
                        (first-denomination kinds-of-coin))
                     kinds-of-coin)))))

; amount = 1; kinds-of-coin = 5;

; 首先是：(cc 1 5))
; (+ (cc 1 4)
;    (cc -49 5))

; 进入 (cc 1 4)
; (+ (cc 1 3)
;    (cc -24 4))

; 进入 (cc 1 3)
; (+ (cc 1 2)
;    (cc -9 3))

; 进入 (cc 1 2)
; (+ (cc 1 1)
;    (cc -4 2))

; 进入 (cc 1 1)
; (+ (cc 1 0)
;    (cc 0 1))

; 进入 (cc 1 0)
; (+ 0 (cc 0 1))

; 进入 (cc 0 1)
; (+ 0 1)

; 结果为 1

  



  